# LP Project

## fixes notes
Regarding H1 and H2
Removed input param and used balances to calculate the amount in

Regarding M-1
Didn't add slippage (because it wasn't mandatory in this project) but just used the min between ratios

Regarding Q-1
Done, just check Swapped event

Regarding Q-2
Done, used `sync()` method as public (to also fix any griefieng attack that could happens)

Regarding Q-3
Since there is no slippage enforced, I preferred to not have the quote check during deposit on router (similar to the solution shared during lecture)

## Frontend info

In order to compile:

- npx hardhat compile
- copy `typechain-types` under /frontend/src

ICO part not changed (just some styling)

Liquidity Pool:

- user can deposit liquidity
- user can remove liquidity
- user can swap eth/spc and spc/eth
- user can set slippage (default 0.10)

### Run frontend

`Note for reviewer:`
Frontend on testnet will start in Open Phase

Liquidity pool has already 1ETH and 5SPC in.

- go into /frontend folder
- add contract address in .env file (there it .env.example to check the variable names)

```shell

npm i

#run with contract on local env
npm start-local # you will need to update SpaceCoinIco.ts and SpaceCoin.ts with the contract address generated by hardhat/foundry

npm start # nothing to add

```


## Technical Spec

<!-- Here you should list the technical requirements of the project. These should include the points given in the project spec, but will go beyond what is given in the spec because that was written by a non-technical client who leaves it up to you to fill in the spec's details -->

SpaceCoinIco:

- withdraw function to that allows to move the invested funds out of the contract and into the treasury address.
- withdraw can be called in any phase (as clarified on discord)
  - answer received `Don't think we actually need to make sure the ICO is (a) finished, or (b) in any particular phase for withdraw to be called.`
- only the owner of the contract can move the funds to the treasury address
- amountRaised won't be updated, otherwise investors can continue to contribute

LiquidityPool:

- ERC20 token (OZ allowed)
- Mints LP tokens for liquidity deposits (ETH + SPC tokens)
- Burns LP tokens to return liquidity to holder
- Accepts trades with a 1% fee

SpaceRouter:

- Add / remove liquidity (no slippage considered, not needed)
- Swap tokens, rejecting if the slippage is above a given amount.
  - 2% SPC tax when calculating slippage not taken in account
- Increase of allowance will be managed from the client
  - for SPC (add liquidity, swap)
  - for LP tokens (remove liquidity)

## Design Exercise Answer

<!-- Answer the Design Exercise. -->
<!-- In your answer: (1) Consider the tradeoffs of your design, and (2) provide some pseudocode, or a diagram, to illustrate how one would get started. -->

> How would you extend your LP contract to award additional rewards – say, a separate ERC-20 token – to further incentivize liquidity providers to deposit into your pool?

(A)
The pool will have an additional amount of an ERC-20 token with a fixed amount (avoid to diluate too much).

- When the ERC-20 is deployed, that amont could be minted directly to the LiquidityPool in order to transfer it directly
- Otherwise, the LiquidityPool contract will have a constant to define the max ERC-20 tokens that can be minted (if we would decide to mint on deposit) and a var to track how much tokens were minted before
  Anytime a user deposit liquidity, the ERC-20 token amount is calculated and minted or transferred.

```solidity
contract LiquidityPool is ERC20 {
  SpaceCoin public immutable spaceCoin;
  SomeERC20 public immutable someErc20;

  ...

  function mint(address to) external payable lock returns (uint256) {
    uint256 liquidity;

    (uint256 _ethReserve, uint256 _spcReserve) = getReserves();

    // using balances, since ETH are sent to the contract
    // and the SPC are transfered before calling this function
    (uint256 _ethBalance, uint256 _spcBalance) = getBalances();

    uint256 ethIn = _ethBalance - ethReserve;
    uint256 spcIn = _spcBalance - spcReserve;

    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
        liquidity = Helpers.sqrt(spcIn * ethIn);
    } else {
        liquidity = Helpers.min((ethIn * _totalSupply) / _ethReserve, (spcIn * _totalSupply) / _spcReserve);
    }

    if (liquidity <= 0) revert NoLiquidityProvided(to);


    /*****************
     *  REWARD ERC20 *
     *****************/
    // liquidity is the % of the user contribution to the pool, based on this an amount can be calculated
    uint256 someErc20Amount = someRulesToCalc();

    // can either be minted directly
    // someErc20._mint()
    // or transferred with someErc20.transfer(to, someErc20Amount) -- in this case could be pre minted and allocated for this pool
    /*****************
     *      END      *
     *****************/


    _mint(to, liquidity);

    ethReserve = _ethBalance;
    spcReserve = _spcBalance;

    emit Minted(msg.sender, ethIn, spcIn);

    return liquidity;
  }
  ...
}
```

(B)
Instead of mint or transfer on liquidity deposit, the ERC-20 token could be distributed once a day (like some DeFi do, ie: osmosis).
An offchain service, running at a specific time of the day, will call the contract to retrieve the liquidity that a user provided.
Based on that, it would calculate how many ERC-20 token will be rewarded to the user and call the ERC-20 send / mint them to the address.
This would require to store somewhere the addresses of liquidity providers (and cycle them on a client / service offchain that will interface with the contract)

## General notes

- Failure of ERC20 transfer was not done since it's using Openzeppelin contract
- Frontend code is not optimized (could be rewritten much better, but focused only on finishing it)

## Deployment notes

`check deploy.ts` if needed

- Token contract is deployed
- Ico contract is deployed
- `this part was in ICO and didn't changed (out of scope)`
  - Token contract will transfers the deployer's SpaceCoin Ico supply to SpaceCoinIco contract address
  ```javascript
  await spaceCoin.transfer(spaceCoinIco.address, spaceCoin.balanceOf(deployer.address));
  ```
- LiquidityPool contract is deployed
- SpaceRouter contract is deployed

## Testnet Deploy Information

| Contract  | Address Etherscan Link                                                                                                        |
| --------- | ----------------------------------------------------------------------------------------------------------------------------- |
| SpaceCoin | [0x6d6571DD43481589d91a908bD8db74103960937e](https://rinkeby.etherscan.io/address/0x6d6571DD43481589d91a908bD8db74103960937e) |
| ICO       | [0x28f21007Cd79DA1aCB998CCDFd89b8966092A56c](https://rinkeby.etherscan.io/address/0x28f21007Cd79DA1aCB998CCDFd89b8966092A56c) |
| Router    | [0x0A49884d6359c70DE5131542DEBF2119785D99a6](https://rinkeby.etherscan.io/address/0x0A49884d6359c70DE5131542DEBF2119785D99a6) |
| Pool      | [0xF1f64C9f582fF9c906A5BF19815D603cE28b2A15](https://rinkeby.etherscan.io/address/0xF1f64C9f582fF9c906A5BF19815D603cE28b2A15) |

## Useful Commands

Try running some of the following commands:

```shell
npx hardhat help
npx hardhat compile              # compile your contracts
npx hardhat test                 # run your tests
npm run test                     # watch for test file changes and automatically run tests
npx hardhat coverage             # generate a test coverage report at coverage/index.html
REPORT_GAS=true npx hardhat test # run your tests and output gas usage metrics
npx hardhat node                 # spin up a fresh in-memory instance of the Ethereum blockchain
npx prettier '**/*.{json,sol,md}' --write # format your Solidity and TS files
```
